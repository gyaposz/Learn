1. Spring MVC

- Web MVC Framework
- Összelõhetõ különbözõ egyéb Framework-ökkel (pl.: JSF, struts)
- Elrendezést pluginokkal is megoldhatjuk (Apache-tiles, SiteMesh)
- De használhatunk lightweight eszközöket is a view-inkhoz (Freemarker, Velocity)

- A Front Controller design patternt valósítja meg dispatcherServleten keresztül.
  Röviden:
  A Front Controller delegálja a kéréseket a dispatcherServleten keresztül az általunk írt controllernek.
  A SpringMVC dönti el, hogy hova küldjük tovább.
  A web.xml-be így elég nekünk csak a dispatcherServletet felvenni.
  Tehát a Front Controller megteszi az alap dolgokat, nekünk csak a controllert kell megírnunk. Ami pedig a modelt adja vissza a viewnak.

-----------------------------------------------
2. Alap annotációk

@Controller annotáció:		class	ezzel készíthetünk egy új controllert.

Handler metódus:

@RequestMapping("/"):			metód	pl: "/", ezzel mondjuk meg, hogy hova mappeljük a controllert.
public String homepage() {
	return "homepage"		ez a visszatérési érték határozza meg, hogy mit renderelünk a usernek.
}

@ModelAttribute("bookshopName"):	metód	pl: "bookshopName", ezzel mondjuk meg, hogy ez a metód egy olyan factory metód, ami olyan értéket ad vissza, amit bele kellene tenni a jspContext-be. Ez a request.setAttribute("bookshopName", "Bookshop") hívással egyenértékû.
public String bookshopName() {
	return "Bookshop";
}

A homepage.jsp esetén a ${bookshopName} használható lesz.

A requestMapping metódusok elõtt hívja meg a ModelAttribute-okat, legyen szó akármennyirõl is.

-----------------------------------------------
3. Összehuzalozás

<context:component-scan base-package="..."/>
<mvc:annotation-driven />

<bean class="org.springframework.web.servlet.view.InternalresourceViewResolver">
	<property name="prefix" value="/WEB-INF/view/"/>
	<property name="suffix" value=".jsp"/>
</bean>

Ez a bean arra való, hogy classpath resource-hoz navigáljon minket. Ez fogja feloldani a RequestMapping által visszaadott értéket.
Ennek a beannek a RequestMapping által visszaadott logikai név egy fájlnévként lesz értelmezve. Elõtte, utána konkatenálunk prefix-szel és suffix-szel.
Ez csak JSP-t tud feloldani, de pl az InternalViewResolver már servletet is. Ez utóbbi mondat szerintem hülyeség, nem találtam InternalViewResolvert.

<servlet>
	<servlet-name>bookshop</>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet

	<init-param>
		<param-name>contextConfigLocation
		<param-value>classpath:spring/mvc-context.xml // mert amúgy a WEB-INF-ben keresné
	</init-param>
	<load-on-startup>1
</servlet>

<servlet-mapping>
	<servlet-name>bookshop
	<url-pattern>/
</servlet-mapping>

-----------------------------------------------
4. RequestMapping in details

Sokfajta requestmappinget támogat az MVC RequestMappingHandlerMapping segítségével.
Narrowing requestmapping:

Consumable media type:

@RequestMapping(value="/",
consumes="application/json")
if Content-Type in request equals "application/json"

Producible media type:

@RequestMapping(value="/",
produces="application/json")
if Accept equals the above ones, then this will run.

method:

@RequestMapping(value="/", method=RequestMethod.GET)
@RequestMapping(value="/", method=RequestMethod.POST)

Request Parameter:

myParam
!myParam
myParam=12
myParam=myValue
@RequestMapping(value="/", params="myParam")

Header value alapján, ugyanaz, mint a request parameter-nél.

header="myParam=myvalue"

Lehetõleg csak egy requestMapping legyen egy controller-ben. Mert a hozzá szükséges ModelAttribute lefut, de az összes. Ha a felesleges modelAttribute közben DB-hez is nyúlunk, akkor performanciát vesztünk.

-----------------------------------------------
5. Handler paraméterek, de mûködik modelAttribute esetén is.

flexibilis, a sorrend tetszõleges.

- HttpServletRequest
- HttpServletResponse
- HttpSession - triviálisak.
Ezeket a Spring MVC magától tölti ki. Nem kötelezõ, a servlet API low level dolgaival nem feltétlenül kell foglalkoznunk, csak ha nagyon kell.

- IOStream
- readers, stb támogatott de nem javasolt.

- @RequestParam
Viszont lehet olyat, hogy: public String page(@RequestParam("paramName") String param)
Ekkor a SpringMVC kiveszi nekünk a paramName-et a requestbõl és beteszi paramba.

- Model
Ez a model, amit látni fog a JSP. Mintha be lenne kopizva a request attributumok között. A model mindig egy map.
public String homepage(Model model) {
	model.addAttribute("currentDate", new Date());
}

És még sok mást is lehet, referenciát/doksit érdemes olvasni.

-----------------------------------------------
5. Handler visszatérési értékek

- String - logikai nevek a weboldalhoz
- Model-lel is vissza lehet térni. Convention over configuration. Nem kell visszaadnunk a viewt, azt hiszem, hogy a RequestMapping-bõl fogja kitalálni, hogy mi lesz a megjelenítendõ view. RequestToViewNameTranslator fogja ezt a kitalálást elvégezni.
- View objektummal is visszatérhetünk.
- ModelAndView-val is vissza lehet térni. return new ModelAndView("homepage", model.asMap());

-----------------------------------------------
6. Forward és redirect

"redirect:files" - Redirectview a visszatérési érték ilyenkor. Ekkor a files nem egy logikai view, hanem egy path/URL.

"forward:homepage.do" - Forward esetén is URL. pl:

RequestMapping(value="/h/g/x.do")
...
return "redirect:homepage" -> /h/g/homepage
return "redirect:/homepage" -> /homepage
return "redirect:/c/homepage" -> /c/homepage
return "redirect:c/homepage" -> /h/g/c/homepage

-----------------------------------------------
7. Logikai view name feloldása (View resolution)

Többfajta van, nem feltétlenül logikai nevekkel dolgoznak.
Lehetnek a view nevek explicitek vagy implicitek.

- InternalResourceviewResolver - Servlet, JSP és leszármazottaik, mint JstlView (InternalResourceView-ek összefoglaló néven)
- XmlViewResolver - xml configuration file for mapping between jsp and view name
- ContentNegotiatingViewResolver - delegátor, ami más viewresolvereknek delegálja a munkát. Pl az URL alapján, hogy milyen extension-je van. Lehet akár header alapján is, pl: Accept="application/pdf"

-----------------------------------------------
8. View resolverek chainelése

A sorrendet explicit beállíthatjuk.
Default chain esetén az lesz a nyerő resolver, amelyik először ad nem null értéket. A ContentNegotiatingViewResolver azonban a legjobban illeszkedőt választja és mindet kigenerálja. Ha mindegyik null-t ad vissza, akkor server exception-t dobunk. lehet order-t megadni, de nem kötelező. (Ha a leggyakoribbat adom meg elsőnek, nyerhetek performanciát.) Mondjuk egy 0-ás jspresolvert csinálunk, meg egy 1-es pdf-eset.

-----------------------------------------------
9. Request processing

Accepting request -> dispatcher servlet -> resolving view -> render view

Accepting request:
- tomcat detects incoming request
- Eldönti, hogy melyik root context felé kell küldeni URL alapján
- web.xml alapján ezt a DispatcherServlet-nek továbbküldi
- DispatcherServlet a Spring Context-ben él, ismeri a Controllereket. megpróbálja oda dispatche-elni a requestet.

Dispatcher servlet:
- RequestMappingHandlerMapping alapján eldönti, hogy a szűkítések alapján melyik Controller illik a requestre (path szűkítés, produces szűkítés, stb.).
- Mivel sok signature-je lehet a handlernek, meg kell nézni, milyen paramétert vár egy ilyen metódus, ezért ezeket még elő kell állítania és azzal meghívni.

Resolving view:
- Vagy elszállunk valami exception-nel a handler lefutása után, vagy
- visszatérünk egy értékkel, amit a DispatcherSerlvet a view resolver chain-nek ad át.
- A view resolverek megtalálják a megfelelő renderelni kívánt view.t

Rendering view:
- View resolver eredménye a response tartalma
- Renderelt response visszakerül a servlet container-hez, innen pedig a clienthez.

-----------------------------------------------
10. Best practices / EPAM standards

- Resource:
	- Default-ból a WEB-INF-be pakolja a spring-es context.xml-t. Nem szoktuk, inkább a classpath-ra tesszük, valami separate package-be instead. tehát classpath:
	- JSP-k a WEB-INF folderben, mert az védett könyvtár. (Ha nem itt van, akkor a JSP-ket simán olvasnánk szövegként, nem pedig generált html-ként.)
- Controller:
	- @ModelAttribute-ot használjuk a model helyett.
	- Request, response, session, model kerülése.
	- És kerüljük a több handlert is egy controllerben.
- Maradjunk Spring MVC-ben, amikor csak lehet. De igyekezzünk ne körbehackelni a servlet API-val.
- pom.xml-be ne tegyünk extra függőséget

-----------------------------------------------
11. N-tier web applications in Spring MVC

Különböző rétegek különböző contextben.
- Context hierarchy:
	- fába rendeződnek. Szülő nem ismeri a gyereket, gyerek látja a szülő beanjeit.
	- alapvetően kettő context-et támogat a spring MVC, de nem akadályoz meg minket, hogy több is legyen.
	- miért jó?	layereket el tudjuk egymástól választani. (pl.: DB kezeléshez minek controller?)
			elzárni beaneket egymástól. Az a réteg, ami a DB-vel kapcsolatban, ne hívjon meg view-val kapcsolatos dolgokat. fordítva talán igen, de cirkuláris referencia elkerülése fontos.
	- Újrafelhasználható layerek. Standardisation, maintainability, testability, easier enhancement, distributed development, layers can be modified independently.

3/12 - 12:00