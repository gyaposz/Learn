1. Spring MVC

- Web MVC Framework
- Összelõhetõ különbözõ egyéb Framework-ökkel (pl.: JSF, struts)
- Elrendezést pluginokkal is megoldhatjuk (Apache-tiles, SiteMesh)
- De használhatunk lightweight eszközöket is a view-inkhoz (Freemarker, Velocity)

- A Front Controller design patternt valósítja meg dispatcherServleten keresztül.
  Röviden:
  A Front Controller delegálja a kéréseket a dispatcherServleten keresztül az általunk írt controllernek.
  A SpringMVC dönti el, hogy hova küldjük tovább.
  A web.xml-beíígy elég nekünk csak a dispatcherServletet felvenni.
  Tehát a Front Controller megteszi az alap dolgokat, nekünk csak a controllert kell megírnunk. Ami pedig a modelt adja vissza a viewnak.

-----------------------------------------------
2. Alap annotációk

@Controller annotáció:		class	ezzel készíthetünk egy új controllert.

Handler metódus:

@RequestMapping("/"):			metód	pl: "/", ezzel mondjuk meg, hogy hova mappeljük a controllert.
public String homepage() {
	return "homepage"		ez a visszatérési érték határozza meg, hogy mit renderelünk a usernek.
}

@ModelAttribute("bookshopName"):	metód	pl: "bookshopName", ezzel mondjuk meg, hogy ez a metód egy olyan factory metód, ami olyan értéket ad vissza, amit bele kellene tenni a jspContext-be. Ez a request.setAttribute("bookshopName", "Bookshop") hívással egyenértékû.
public String bookshopName() {
	return "Bookshop";
}

A requestMapping metódusok elõtt hívja meg a ModelAttribute-okat, legyen szó akármennyirõl is.

-----------------------------------------------
3. Összehuzalozás

<context:component-scan base-package="..."/>
<mvc:annotation-driven />

<bean class="org.springframework.web.servlet.view.InternalresourceViewResolver">
	<property name="prefix" value="/WEB-INF/view/"/>
	<property name="suffix" value=".jsp"/>
</bean>

Ez a bean arra való, hogy classpath resource-hoz navigáljon minket. Ez fogja feloldani a RequestMapping által visszaadott értéket.
Ennek a beannek a RequestMapping által visszaadott logikai név egy fájlnévként lesz értelmezve. Elõtte, utána konkatenálunk prefix-szel és suffix-szel. Ez csak JSP-t tud feloldani, de pl az InternalViewResolver már servletet is.

A homepage.jsp esetén a ${bookshopName} használható lesz.

<servlet>
	<servlet-name>bookshop</>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet

	<init-param>
		<param-name>contextConfigLocation
		<param-value>classpath:spring/mvc-context.xml // mert am]gz a WEBINF/ben keresn;
	</init-param>
	<load-on-startup>1
</servlet>

<servlet-mapping>
	<servlet-name>bookshop
	<url-pattern>/
</servlet-mapping>

-----------------------------------------------
4. RequestMapping in details

Sokfajta requestmappinget támogat az MVC RequestMappingHandlerMapping segítségével.
Narrowing requestmapping:

Consumable media type:

@RequestMapping(value="/",
consumes="application/json")
if Content-Type in request equals "application/json"

Producible media type:

@RequestMapping(value="/",
produces="application/json")
if Accept equals the above ones, then this will run.

method:

@RequestMapping(value="/", method=RequestMethod.GET)
@RequestMapping(value="/", method=RequestMethod.POST)

Request Parameter:

myParam
!myParam
myParam=12
myParam=myValue
@RequestMapping(value="/", params="myParam")

Header value alapján, ugyanaz, mint a request parameter-nél.

header="myParam=myvalue"

Lehetõleg csak egy requestMapping legyen egy controller-ben. Mert a hozzá szükséges ModelAttribute lefut, de az összes. Ha a modelAttribute közben DB-hez is nyúlunk, akkor performanciát vesztünk.

-----------------------------------------------
5. Handler paraméterek, de mûködik modelAttribute esetén is.

flexibilis, a sorrend tetszõleges.

- HttpServletRequest
- HttpServletResponse
- HttpSession - triviálisak.
Ezeket a Spring MVC magától tölti ki. Nem kötelezõ, a servlet API low level dolgaival nem feltétlenül kell foglalkoznunk, csak ha nagyon kell.

- IOStream
- readers, stb támogatott de nem javasolt.

- @RequestParam
Viszont lehet olyat, hogy: public String page(@RequestParam("paramName") String param)
Ekkor a SpringMVC kiveszi nekünk a paramName-et a requestbõl és beteszi paramba.

- Model
Ez a model, amit látni fog a JSP. Mintha be lenne kopizva a request attributumok között. A model mindig egy map.
public String homepage(Model model) {
	model.addAttribute("currentDate", new Date());
}

És még sok mást is lehet, referenciát/doksit érdemes olvasni.

-----------------------------------------------
5. Handler visszatérési értékek

- String - logikai nevek a weboldalhoz
- Model-lel is vissza lehet térni. Convention over configuration. Nem kell visszaadnunk a modelt, azt hiszem, hogy a RequestMapping-bõl fogja kitalálni, hogy mi lesz a megjelenítendõ view. RequestToViewNameTranslator fogja ezt a kitalálást elvégezni.
- View objektummal is visszatérhetünk.
- ModelAndView-val is vissza lehet térni. return new ModelAndView("homepage", model.asMap());

-----------------------------------------------
6. Forward és redirect

"redirect:files" - Redirectview a visszatérési érték ilyenkor. Ekkor a files nem egy logikai view, hanem egy path/URL.

"forward:homepage.do" - Forward esetén is URL. pl:

RequestMapping(value="/h/g/x.do")
...
return "redirect:homepage" -> /h/g/homepage
return "redirect:/homepage" -> /homepage
return "redirect:/c/homepage" -> /c/homepage
return "redirect:c/homepage" -> /h/g/c/homepage

-----------------------------------------------
7. Logikai view name feloldása (View resolution)

Többfajta van, nem feltétlenül logikai nevekkel dolgoznak.
Lehetnek a view nevek explicitek vagy implicitek.

- InternalResourceviewResolver - Servlet, JSP
- XmlViewResolver - xml configuration file for mapping between jsp and view name
- ContentNegotiatingViewResolver

22:00